/*
 * petscSolveCRS_mex.c
 *
 * Auxiliary code for mexFunction of petscSolveCRS
 *
 * C source code generated by m2c.
 * %#m2c options:a99e11a6ead7567ab33b4ae2f946f2c3
 *
 */

#include "mex.h"
#if !defined(MATLAB_MEX_FILE) && defined(printf)
#undef printf
#endif
/* Include the C header file generated by codegen in lib mode */
#include "petscSolveCRS.h"
#include "petscSolveCRS_types.h"
#include "m2c.c"

/* Include declaration of some helper functions. */
#include "lib2mex_helper.c"


static void __petscSolveCRS_api(mxArray **plhs, const mxArray ** prhs) {
    int32_T             *flag;
    real64_T            *relres;
    int32_T             *iter;
    real64_T            *times;
    double               _timestamp;

    int                  _dims[1];

    /* Marshall in inputs and preallocate outputs */
    flag = (int32_T*)mxMalloc(sizeof(int32_T));

    relres = (real64_T*)mxMalloc(sizeof(real64_T));

    iter = (int32_T*)mxMalloc(sizeof(int32_T));

    times = (real64_T*)mxMalloc(sizeof(real64_T) * 2);

    /* Invoke the target function */
    _timestamp = M2C_wtime();
    petscSolveCRS(flag, relres, iter, times);
    _timestamp = M2C_wtime() - _timestamp;
    printf("Function petscSolveCRS completed in %g seconds.\n", _timestamp);

    /* Deallocate input and marshall out function outputs */
    plhs[1] = move_scalar_to_mxArray(flag, mxINT32_CLASS);
    plhs[2] = move_scalar_to_mxArray(relres, mxDOUBLE_CLASS);
    plhs[3] = move_scalar_to_mxArray(iter, mxINT32_CLASS);
    _dims[0] = 2;
    plhs[5] = move_array_to_mxArray(times, mxDOUBLE_CLASS, 1, _dims);
    /* Creating empty mxArray for pruned variable x */
    _dims[0] = 0;
    plhs[0] = copy_array_to_mxArray(NULL, mxDOUBLE_CLASS, 1, _dims);
    /* Creating empty mxArray for pruned variable reshis */
    _dims[0] = 0;
    plhs[4] = copy_array_to_mxArray(NULL, mxDOUBLE_CLASS, 1, _dims);

}

static void __petscSolveCRS_4args_api(mxArray **plhs, const mxArray ** prhs) {
    emxArray_int32_T     Arows;
    emxArray_int32_T     Acols;
    emxArray_real_T      Avals;
    emxArray_real_T      b;
    emxArray_real_T      x;
    int32_T             *flag;
    real64_T            *relres;
    int32_T             *iter;
    emxArray_real_T      reshis;
    real64_T            *times;
    double               _timestamp;

    int                  _dims[1];

    /* Marshall in inputs and preallocate outputs */
    if (mxGetNumberOfElements(prhs[0]) && mxGetClassID(prhs[0]) != mxINT32_CLASS)
        mexErrMsgIdAndTxt("petscSolveCRS_4args:WrongInputType",
            "Input argument Arows has incorrect data type; int32 is expected.");
    if (mxGetNumberOfElements(prhs[0]) && mxGetDimensions(prhs[0])[1] != 1) 
        mexErrMsgIdAndTxt("petscSolveCRS_4args:WrongSizeOfInputArg",
            "Dimension 2 of Arows should be equal to 1.");
    alias_mxArray_to_emxArray(prhs[0], (emxArray__common *)(&Arows), "Arows", 1);

    if (mxGetNumberOfElements(prhs[1]) && mxGetClassID(prhs[1]) != mxINT32_CLASS)
        mexErrMsgIdAndTxt("petscSolveCRS_4args:WrongInputType",
            "Input argument Acols has incorrect data type; int32 is expected.");
    if (mxGetNumberOfElements(prhs[1]) && mxGetDimensions(prhs[1])[1] != 1) 
        mexErrMsgIdAndTxt("petscSolveCRS_4args:WrongSizeOfInputArg",
            "Dimension 2 of Acols should be equal to 1.");
    alias_mxArray_to_emxArray(prhs[1], (emxArray__common *)(&Acols), "Acols", 1);

    if (mxGetNumberOfElements(prhs[2]) && mxGetClassID(prhs[2]) != mxDOUBLE_CLASS)
        mexErrMsgIdAndTxt("petscSolveCRS_4args:WrongInputType",
            "Input argument Avals has incorrect data type; double is expected.");
    if (mxGetNumberOfElements(prhs[2]) && mxGetDimensions(prhs[2])[1] != 1) 
        mexErrMsgIdAndTxt("petscSolveCRS_4args:WrongSizeOfInputArg",
            "Dimension 2 of Avals should be equal to 1.");
    alias_mxArray_to_emxArray(prhs[2], (emxArray__common *)(&Avals), "Avals", 1);

    if (mxGetNumberOfElements(prhs[3]) && mxGetClassID(prhs[3]) != mxDOUBLE_CLASS)
        mexErrMsgIdAndTxt("petscSolveCRS_4args:WrongInputType",
            "Input argument b has incorrect data type; double is expected.");
    if (mxGetNumberOfElements(prhs[3]) && mxGetDimensions(prhs[3])[1] != 1) 
        mexErrMsgIdAndTxt("petscSolveCRS_4args:WrongSizeOfInputArg",
            "Dimension 2 of b should be equal to 1.");
    alias_mxArray_to_emxArray(prhs[3], (emxArray__common *)(&b), "b", 1);
    init_emxArray((emxArray__common*)(&x), 1);

    flag = (int32_T*)mxMalloc(sizeof(int32_T));

    relres = (real64_T*)mxMalloc(sizeof(real64_T));

    iter = (int32_T*)mxMalloc(sizeof(int32_T));
    init_emxArray((emxArray__common*)(&reshis), 1);

    times = (real64_T*)mxMalloc(sizeof(real64_T) * 2);

    /* Invoke the target function */
    _timestamp = M2C_wtime();
    petscSolveCRS_4args(&Arows, &Acols, &Avals, &b, &x, flag, relres, iter, &reshis, times);
    _timestamp = M2C_wtime() - _timestamp;
    printf("Function petscSolveCRS completed in %g seconds.\n", _timestamp);

    /* Deallocate input and marshall out function outputs */
    free_emxArray((emxArray__common*)(&Arows));
    free_emxArray((emxArray__common*)(&Acols));
    free_emxArray((emxArray__common*)(&Avals));
    free_emxArray((emxArray__common*)(&b));
    plhs[0] = move_emxArray_to_mxArray((emxArray__common*)(&x), mxDOUBLE_CLASS);
    mxFree(x.size);
    plhs[1] = move_scalar_to_mxArray(flag, mxINT32_CLASS);
    plhs[2] = move_scalar_to_mxArray(relres, mxDOUBLE_CLASS);
    plhs[3] = move_scalar_to_mxArray(iter, mxINT32_CLASS);
    plhs[4] = move_emxArray_to_mxArray((emxArray__common*)(&reshis), mxDOUBLE_CLASS);
    mxFree(reshis.size);
    _dims[0] = 2;
    plhs[5] = move_array_to_mxArray(times, mxDOUBLE_CLASS, 1, _dims);

}

static void __petscSolveCRS_5args_api(mxArray **plhs, const mxArray ** prhs) {
    emxArray_int32_T     Arows;
    emxArray_int32_T     Acols;
    emxArray_real_T      Avals;
    emxArray_real_T      b;
    emxArray_char_T      solver;
    emxArray_real_T      x;
    int32_T             *flag;
    real64_T            *relres;
    int32_T             *iter;
    emxArray_real_T      reshis;
    real64_T            *times;
    double               _timestamp;

    int                  _dims[1];

    /* Marshall in inputs and preallocate outputs */
    if (mxGetNumberOfElements(prhs[0]) && mxGetClassID(prhs[0]) != mxINT32_CLASS)
        mexErrMsgIdAndTxt("petscSolveCRS_5args:WrongInputType",
            "Input argument Arows has incorrect data type; int32 is expected.");
    if (mxGetNumberOfElements(prhs[0]) && mxGetDimensions(prhs[0])[1] != 1) 
        mexErrMsgIdAndTxt("petscSolveCRS_5args:WrongSizeOfInputArg",
            "Dimension 2 of Arows should be equal to 1.");
    alias_mxArray_to_emxArray(prhs[0], (emxArray__common *)(&Arows), "Arows", 1);

    if (mxGetNumberOfElements(prhs[1]) && mxGetClassID(prhs[1]) != mxINT32_CLASS)
        mexErrMsgIdAndTxt("petscSolveCRS_5args:WrongInputType",
            "Input argument Acols has incorrect data type; int32 is expected.");
    if (mxGetNumberOfElements(prhs[1]) && mxGetDimensions(prhs[1])[1] != 1) 
        mexErrMsgIdAndTxt("petscSolveCRS_5args:WrongSizeOfInputArg",
            "Dimension 2 of Acols should be equal to 1.");
    alias_mxArray_to_emxArray(prhs[1], (emxArray__common *)(&Acols), "Acols", 1);

    if (mxGetNumberOfElements(prhs[2]) && mxGetClassID(prhs[2]) != mxDOUBLE_CLASS)
        mexErrMsgIdAndTxt("petscSolveCRS_5args:WrongInputType",
            "Input argument Avals has incorrect data type; double is expected.");
    if (mxGetNumberOfElements(prhs[2]) && mxGetDimensions(prhs[2])[1] != 1) 
        mexErrMsgIdAndTxt("petscSolveCRS_5args:WrongSizeOfInputArg",
            "Dimension 2 of Avals should be equal to 1.");
    alias_mxArray_to_emxArray(prhs[2], (emxArray__common *)(&Avals), "Avals", 1);

    if (mxGetNumberOfElements(prhs[3]) && mxGetClassID(prhs[3]) != mxDOUBLE_CLASS)
        mexErrMsgIdAndTxt("petscSolveCRS_5args:WrongInputType",
            "Input argument b has incorrect data type; double is expected.");
    if (mxGetNumberOfElements(prhs[3]) && mxGetDimensions(prhs[3])[1] != 1) 
        mexErrMsgIdAndTxt("petscSolveCRS_5args:WrongSizeOfInputArg",
            "Dimension 2 of b should be equal to 1.");
    alias_mxArray_to_emxArray(prhs[3], (emxArray__common *)(&b), "b", 1);

    if (mxGetNumberOfElements(prhs[4]) && mxGetClassID(prhs[4]) != mxCHAR_CLASS)
        mexErrMsgIdAndTxt("petscSolveCRS_5args:WrongInputType",
            "Input argument solver has incorrect data type; char is expected.");
    if (mxGetNumberOfElements(prhs[4]) && mxGetDimensions(prhs[4])[0] != 1) 
        mexErrMsgIdAndTxt("petscSolveCRS_5args:WrongSizeOfInputArg",
            "Dimension 1 of solver should be equal to 1.");
    alias_mxArray_to_emxArray(prhs[4], (emxArray__common *)(&solver), "solver", 2);
    init_emxArray((emxArray__common*)(&x), 1);

    flag = (int32_T*)mxMalloc(sizeof(int32_T));

    relres = (real64_T*)mxMalloc(sizeof(real64_T));

    iter = (int32_T*)mxMalloc(sizeof(int32_T));
    init_emxArray((emxArray__common*)(&reshis), 1);

    times = (real64_T*)mxMalloc(sizeof(real64_T) * 2);

    /* Invoke the target function */
    _timestamp = M2C_wtime();
    petscSolveCRS_5args(&Arows, &Acols, &Avals, &b, &solver, &x, flag, relres, iter, &reshis, times);
    _timestamp = M2C_wtime() - _timestamp;
    printf("Function petscSolveCRS completed in %g seconds.\n", _timestamp);

    /* Deallocate input and marshall out function outputs */
    free_emxArray((emxArray__common*)(&Arows));
    free_emxArray((emxArray__common*)(&Acols));
    free_emxArray((emxArray__common*)(&Avals));
    free_emxArray((emxArray__common*)(&b));
    free_emxArray((emxArray__common*)(&solver));
    plhs[0] = move_emxArray_to_mxArray((emxArray__common*)(&x), mxDOUBLE_CLASS);
    mxFree(x.size);
    plhs[1] = move_scalar_to_mxArray(flag, mxINT32_CLASS);
    plhs[2] = move_scalar_to_mxArray(relres, mxDOUBLE_CLASS);
    plhs[3] = move_scalar_to_mxArray(iter, mxINT32_CLASS);
    plhs[4] = move_emxArray_to_mxArray((emxArray__common*)(&reshis), mxDOUBLE_CLASS);
    mxFree(reshis.size);
    _dims[0] = 2;
    plhs[5] = move_array_to_mxArray(times, mxDOUBLE_CLASS, 1, _dims);

}

static void __petscSolveCRS_6args_api(mxArray **plhs, const mxArray ** prhs) {
    emxArray_int32_T     Arows;
    emxArray_int32_T     Acols;
    emxArray_real_T      Avals;
    emxArray_real_T      b;
    emxArray_char_T      solver;
    real64_T             rtol;
    emxArray_real_T      x;
    int32_T             *flag;
    real64_T            *relres;
    int32_T             *iter;
    emxArray_real_T      reshis;
    real64_T            *times;
    double               _timestamp;

    int                  _dims[1];

    /* Marshall in inputs and preallocate outputs */
    if (mxGetNumberOfElements(prhs[0]) && mxGetClassID(prhs[0]) != mxINT32_CLASS)
        mexErrMsgIdAndTxt("petscSolveCRS_6args:WrongInputType",
            "Input argument Arows has incorrect data type; int32 is expected.");
    if (mxGetNumberOfElements(prhs[0]) && mxGetDimensions(prhs[0])[1] != 1) 
        mexErrMsgIdAndTxt("petscSolveCRS_6args:WrongSizeOfInputArg",
            "Dimension 2 of Arows should be equal to 1.");
    alias_mxArray_to_emxArray(prhs[0], (emxArray__common *)(&Arows), "Arows", 1);

    if (mxGetNumberOfElements(prhs[1]) && mxGetClassID(prhs[1]) != mxINT32_CLASS)
        mexErrMsgIdAndTxt("petscSolveCRS_6args:WrongInputType",
            "Input argument Acols has incorrect data type; int32 is expected.");
    if (mxGetNumberOfElements(prhs[1]) && mxGetDimensions(prhs[1])[1] != 1) 
        mexErrMsgIdAndTxt("petscSolveCRS_6args:WrongSizeOfInputArg",
            "Dimension 2 of Acols should be equal to 1.");
    alias_mxArray_to_emxArray(prhs[1], (emxArray__common *)(&Acols), "Acols", 1);

    if (mxGetNumberOfElements(prhs[2]) && mxGetClassID(prhs[2]) != mxDOUBLE_CLASS)
        mexErrMsgIdAndTxt("petscSolveCRS_6args:WrongInputType",
            "Input argument Avals has incorrect data type; double is expected.");
    if (mxGetNumberOfElements(prhs[2]) && mxGetDimensions(prhs[2])[1] != 1) 
        mexErrMsgIdAndTxt("petscSolveCRS_6args:WrongSizeOfInputArg",
            "Dimension 2 of Avals should be equal to 1.");
    alias_mxArray_to_emxArray(prhs[2], (emxArray__common *)(&Avals), "Avals", 1);

    if (mxGetNumberOfElements(prhs[3]) && mxGetClassID(prhs[3]) != mxDOUBLE_CLASS)
        mexErrMsgIdAndTxt("petscSolveCRS_6args:WrongInputType",
            "Input argument b has incorrect data type; double is expected.");
    if (mxGetNumberOfElements(prhs[3]) && mxGetDimensions(prhs[3])[1] != 1) 
        mexErrMsgIdAndTxt("petscSolveCRS_6args:WrongSizeOfInputArg",
            "Dimension 2 of b should be equal to 1.");
    alias_mxArray_to_emxArray(prhs[3], (emxArray__common *)(&b), "b", 1);

    if (mxGetNumberOfElements(prhs[4]) && mxGetClassID(prhs[4]) != mxCHAR_CLASS)
        mexErrMsgIdAndTxt("petscSolveCRS_6args:WrongInputType",
            "Input argument solver has incorrect data type; char is expected.");
    if (mxGetNumberOfElements(prhs[4]) && mxGetDimensions(prhs[4])[0] != 1) 
        mexErrMsgIdAndTxt("petscSolveCRS_6args:WrongSizeOfInputArg",
            "Dimension 1 of solver should be equal to 1.");
    alias_mxArray_to_emxArray(prhs[4], (emxArray__common *)(&solver), "solver", 2);

    if (mxGetNumberOfElements(prhs[5]) && mxGetClassID(prhs[5]) != mxDOUBLE_CLASS)
        mexErrMsgIdAndTxt("petscSolveCRS_6args:WrongInputType",
            "Input argument rtol has incorrect data type; double is expected.");
    if (mxGetNumberOfElements(prhs[5]) != 1)
        mexErrMsgIdAndTxt("petscSolveCRS_6args:WrongSizeOfInputArg",
            "Argument rtol should be a scalar.");
    rtol = *(real64_T*)mxGetData(prhs[5]);
    init_emxArray((emxArray__common*)(&x), 1);

    flag = (int32_T*)mxMalloc(sizeof(int32_T));

    relres = (real64_T*)mxMalloc(sizeof(real64_T));

    iter = (int32_T*)mxMalloc(sizeof(int32_T));
    init_emxArray((emxArray__common*)(&reshis), 1);

    times = (real64_T*)mxMalloc(sizeof(real64_T) * 2);

    /* Invoke the target function */
    _timestamp = M2C_wtime();
    petscSolveCRS_6args(&Arows, &Acols, &Avals, &b, &solver, rtol, &x, flag, relres, iter, &reshis, times);
    _timestamp = M2C_wtime() - _timestamp;
    printf("Function petscSolveCRS completed in %g seconds.\n", _timestamp);

    /* Deallocate input and marshall out function outputs */
    free_emxArray((emxArray__common*)(&Arows));
    free_emxArray((emxArray__common*)(&Acols));
    free_emxArray((emxArray__common*)(&Avals));
    free_emxArray((emxArray__common*)(&b));
    free_emxArray((emxArray__common*)(&solver));
    /* Nothing to be done for rtol */
    plhs[0] = move_emxArray_to_mxArray((emxArray__common*)(&x), mxDOUBLE_CLASS);
    mxFree(x.size);
    plhs[1] = move_scalar_to_mxArray(flag, mxINT32_CLASS);
    plhs[2] = move_scalar_to_mxArray(relres, mxDOUBLE_CLASS);
    plhs[3] = move_scalar_to_mxArray(iter, mxINT32_CLASS);
    plhs[4] = move_emxArray_to_mxArray((emxArray__common*)(&reshis), mxDOUBLE_CLASS);
    mxFree(reshis.size);
    _dims[0] = 2;
    plhs[5] = move_array_to_mxArray(times, mxDOUBLE_CLASS, 1, _dims);

}

static void __petscSolveCRS_7args_api(mxArray **plhs, const mxArray ** prhs) {
    emxArray_int32_T     Arows;
    emxArray_int32_T     Acols;
    emxArray_real_T      Avals;
    emxArray_real_T      b;
    emxArray_char_T      solver;
    real64_T             rtol;
    int32_T              maxiter;
    emxArray_real_T      x;
    int32_T             *flag;
    real64_T            *relres;
    int32_T             *iter;
    emxArray_real_T      reshis;
    real64_T            *times;
    double               _timestamp;

    int                  _dims[1];

    /* Marshall in inputs and preallocate outputs */
    if (mxGetNumberOfElements(prhs[0]) && mxGetClassID(prhs[0]) != mxINT32_CLASS)
        mexErrMsgIdAndTxt("petscSolveCRS_7args:WrongInputType",
            "Input argument Arows has incorrect data type; int32 is expected.");
    if (mxGetNumberOfElements(prhs[0]) && mxGetDimensions(prhs[0])[1] != 1) 
        mexErrMsgIdAndTxt("petscSolveCRS_7args:WrongSizeOfInputArg",
            "Dimension 2 of Arows should be equal to 1.");
    alias_mxArray_to_emxArray(prhs[0], (emxArray__common *)(&Arows), "Arows", 1);

    if (mxGetNumberOfElements(prhs[1]) && mxGetClassID(prhs[1]) != mxINT32_CLASS)
        mexErrMsgIdAndTxt("petscSolveCRS_7args:WrongInputType",
            "Input argument Acols has incorrect data type; int32 is expected.");
    if (mxGetNumberOfElements(prhs[1]) && mxGetDimensions(prhs[1])[1] != 1) 
        mexErrMsgIdAndTxt("petscSolveCRS_7args:WrongSizeOfInputArg",
            "Dimension 2 of Acols should be equal to 1.");
    alias_mxArray_to_emxArray(prhs[1], (emxArray__common *)(&Acols), "Acols", 1);

    if (mxGetNumberOfElements(prhs[2]) && mxGetClassID(prhs[2]) != mxDOUBLE_CLASS)
        mexErrMsgIdAndTxt("petscSolveCRS_7args:WrongInputType",
            "Input argument Avals has incorrect data type; double is expected.");
    if (mxGetNumberOfElements(prhs[2]) && mxGetDimensions(prhs[2])[1] != 1) 
        mexErrMsgIdAndTxt("petscSolveCRS_7args:WrongSizeOfInputArg",
            "Dimension 2 of Avals should be equal to 1.");
    alias_mxArray_to_emxArray(prhs[2], (emxArray__common *)(&Avals), "Avals", 1);

    if (mxGetNumberOfElements(prhs[3]) && mxGetClassID(prhs[3]) != mxDOUBLE_CLASS)
        mexErrMsgIdAndTxt("petscSolveCRS_7args:WrongInputType",
            "Input argument b has incorrect data type; double is expected.");
    if (mxGetNumberOfElements(prhs[3]) && mxGetDimensions(prhs[3])[1] != 1) 
        mexErrMsgIdAndTxt("petscSolveCRS_7args:WrongSizeOfInputArg",
            "Dimension 2 of b should be equal to 1.");
    alias_mxArray_to_emxArray(prhs[3], (emxArray__common *)(&b), "b", 1);

    if (mxGetNumberOfElements(prhs[4]) && mxGetClassID(prhs[4]) != mxCHAR_CLASS)
        mexErrMsgIdAndTxt("petscSolveCRS_7args:WrongInputType",
            "Input argument solver has incorrect data type; char is expected.");
    if (mxGetNumberOfElements(prhs[4]) && mxGetDimensions(prhs[4])[0] != 1) 
        mexErrMsgIdAndTxt("petscSolveCRS_7args:WrongSizeOfInputArg",
            "Dimension 1 of solver should be equal to 1.");
    alias_mxArray_to_emxArray(prhs[4], (emxArray__common *)(&solver), "solver", 2);

    if (mxGetNumberOfElements(prhs[5]) && mxGetClassID(prhs[5]) != mxDOUBLE_CLASS)
        mexErrMsgIdAndTxt("petscSolveCRS_7args:WrongInputType",
            "Input argument rtol has incorrect data type; double is expected.");
    if (mxGetNumberOfElements(prhs[5]) != 1)
        mexErrMsgIdAndTxt("petscSolveCRS_7args:WrongSizeOfInputArg",
            "Argument rtol should be a scalar.");
    rtol = *(real64_T*)mxGetData(prhs[5]);

    if (mxGetNumberOfElements(prhs[6]) && mxGetClassID(prhs[6]) != mxINT32_CLASS)
        mexErrMsgIdAndTxt("petscSolveCRS_7args:WrongInputType",
            "Input argument maxiter has incorrect data type; int32 is expected.");
    if (mxGetNumberOfElements(prhs[6]) != 1)
        mexErrMsgIdAndTxt("petscSolveCRS_7args:WrongSizeOfInputArg",
            "Argument maxiter should be a scalar.");
    maxiter = *(int32_T*)mxGetData(prhs[6]);
    init_emxArray((emxArray__common*)(&x), 1);

    flag = (int32_T*)mxMalloc(sizeof(int32_T));

    relres = (real64_T*)mxMalloc(sizeof(real64_T));

    iter = (int32_T*)mxMalloc(sizeof(int32_T));
    init_emxArray((emxArray__common*)(&reshis), 1);

    times = (real64_T*)mxMalloc(sizeof(real64_T) * 2);

    /* Invoke the target function */
    _timestamp = M2C_wtime();
    petscSolveCRS_7args(&Arows, &Acols, &Avals, &b, &solver, rtol, maxiter, &x, flag, relres, iter, &reshis, times);
    _timestamp = M2C_wtime() - _timestamp;
    printf("Function petscSolveCRS completed in %g seconds.\n", _timestamp);

    /* Deallocate input and marshall out function outputs */
    free_emxArray((emxArray__common*)(&Arows));
    free_emxArray((emxArray__common*)(&Acols));
    free_emxArray((emxArray__common*)(&Avals));
    free_emxArray((emxArray__common*)(&b));
    free_emxArray((emxArray__common*)(&solver));
    /* Nothing to be done for rtol */
    /* Nothing to be done for maxiter */
    plhs[0] = move_emxArray_to_mxArray((emxArray__common*)(&x), mxDOUBLE_CLASS);
    mxFree(x.size);
    plhs[1] = move_scalar_to_mxArray(flag, mxINT32_CLASS);
    plhs[2] = move_scalar_to_mxArray(relres, mxDOUBLE_CLASS);
    plhs[3] = move_scalar_to_mxArray(iter, mxINT32_CLASS);
    plhs[4] = move_emxArray_to_mxArray((emxArray__common*)(&reshis), mxDOUBLE_CLASS);
    mxFree(reshis.size);
    _dims[0] = 2;
    plhs[5] = move_array_to_mxArray(times, mxDOUBLE_CLASS, 1, _dims);

}

static void __petscSolveCRS_8args_api(mxArray **plhs, const mxArray ** prhs) {
    emxArray_int32_T     Arows;
    emxArray_int32_T     Acols;
    emxArray_real_T      Avals;
    emxArray_real_T      b;
    emxArray_char_T      solver;
    real64_T             rtol;
    int32_T              maxiter;
    emxArray_char_T      pctype;
    emxArray_real_T      x;
    int32_T             *flag;
    real64_T            *relres;
    int32_T             *iter;
    emxArray_real_T      reshis;
    real64_T            *times;
    double               _timestamp;

    int                  _dims[1];

    /* Marshall in inputs and preallocate outputs */
    if (mxGetNumberOfElements(prhs[0]) && mxGetClassID(prhs[0]) != mxINT32_CLASS)
        mexErrMsgIdAndTxt("petscSolveCRS_8args:WrongInputType",
            "Input argument Arows has incorrect data type; int32 is expected.");
    if (mxGetNumberOfElements(prhs[0]) && mxGetDimensions(prhs[0])[1] != 1) 
        mexErrMsgIdAndTxt("petscSolveCRS_8args:WrongSizeOfInputArg",
            "Dimension 2 of Arows should be equal to 1.");
    alias_mxArray_to_emxArray(prhs[0], (emxArray__common *)(&Arows), "Arows", 1);

    if (mxGetNumberOfElements(prhs[1]) && mxGetClassID(prhs[1]) != mxINT32_CLASS)
        mexErrMsgIdAndTxt("petscSolveCRS_8args:WrongInputType",
            "Input argument Acols has incorrect data type; int32 is expected.");
    if (mxGetNumberOfElements(prhs[1]) && mxGetDimensions(prhs[1])[1] != 1) 
        mexErrMsgIdAndTxt("petscSolveCRS_8args:WrongSizeOfInputArg",
            "Dimension 2 of Acols should be equal to 1.");
    alias_mxArray_to_emxArray(prhs[1], (emxArray__common *)(&Acols), "Acols", 1);

    if (mxGetNumberOfElements(prhs[2]) && mxGetClassID(prhs[2]) != mxDOUBLE_CLASS)
        mexErrMsgIdAndTxt("petscSolveCRS_8args:WrongInputType",
            "Input argument Avals has incorrect data type; double is expected.");
    if (mxGetNumberOfElements(prhs[2]) && mxGetDimensions(prhs[2])[1] != 1) 
        mexErrMsgIdAndTxt("petscSolveCRS_8args:WrongSizeOfInputArg",
            "Dimension 2 of Avals should be equal to 1.");
    alias_mxArray_to_emxArray(prhs[2], (emxArray__common *)(&Avals), "Avals", 1);

    if (mxGetNumberOfElements(prhs[3]) && mxGetClassID(prhs[3]) != mxDOUBLE_CLASS)
        mexErrMsgIdAndTxt("petscSolveCRS_8args:WrongInputType",
            "Input argument b has incorrect data type; double is expected.");
    if (mxGetNumberOfElements(prhs[3]) && mxGetDimensions(prhs[3])[1] != 1) 
        mexErrMsgIdAndTxt("petscSolveCRS_8args:WrongSizeOfInputArg",
            "Dimension 2 of b should be equal to 1.");
    alias_mxArray_to_emxArray(prhs[3], (emxArray__common *)(&b), "b", 1);

    if (mxGetNumberOfElements(prhs[4]) && mxGetClassID(prhs[4]) != mxCHAR_CLASS)
        mexErrMsgIdAndTxt("petscSolveCRS_8args:WrongInputType",
            "Input argument solver has incorrect data type; char is expected.");
    if (mxGetNumberOfElements(prhs[4]) && mxGetDimensions(prhs[4])[0] != 1) 
        mexErrMsgIdAndTxt("petscSolveCRS_8args:WrongSizeOfInputArg",
            "Dimension 1 of solver should be equal to 1.");
    alias_mxArray_to_emxArray(prhs[4], (emxArray__common *)(&solver), "solver", 2);

    if (mxGetNumberOfElements(prhs[5]) && mxGetClassID(prhs[5]) != mxDOUBLE_CLASS)
        mexErrMsgIdAndTxt("petscSolveCRS_8args:WrongInputType",
            "Input argument rtol has incorrect data type; double is expected.");
    if (mxGetNumberOfElements(prhs[5]) != 1)
        mexErrMsgIdAndTxt("petscSolveCRS_8args:WrongSizeOfInputArg",
            "Argument rtol should be a scalar.");
    rtol = *(real64_T*)mxGetData(prhs[5]);

    if (mxGetNumberOfElements(prhs[6]) && mxGetClassID(prhs[6]) != mxINT32_CLASS)
        mexErrMsgIdAndTxt("petscSolveCRS_8args:WrongInputType",
            "Input argument maxiter has incorrect data type; int32 is expected.");
    if (mxGetNumberOfElements(prhs[6]) != 1)
        mexErrMsgIdAndTxt("petscSolveCRS_8args:WrongSizeOfInputArg",
            "Argument maxiter should be a scalar.");
    maxiter = *(int32_T*)mxGetData(prhs[6]);

    if (mxGetNumberOfElements(prhs[7]) && mxGetClassID(prhs[7]) != mxCHAR_CLASS)
        mexErrMsgIdAndTxt("petscSolveCRS_8args:WrongInputType",
            "Input argument pctype has incorrect data type; char is expected.");
    if (mxGetNumberOfElements(prhs[7]) && mxGetDimensions(prhs[7])[0] != 1) 
        mexErrMsgIdAndTxt("petscSolveCRS_8args:WrongSizeOfInputArg",
            "Dimension 1 of pctype should be equal to 1.");
    alias_mxArray_to_emxArray(prhs[7], (emxArray__common *)(&pctype), "pctype", 2);
    init_emxArray((emxArray__common*)(&x), 1);

    flag = (int32_T*)mxMalloc(sizeof(int32_T));

    relres = (real64_T*)mxMalloc(sizeof(real64_T));

    iter = (int32_T*)mxMalloc(sizeof(int32_T));
    init_emxArray((emxArray__common*)(&reshis), 1);

    times = (real64_T*)mxMalloc(sizeof(real64_T) * 2);

    /* Invoke the target function */
    _timestamp = M2C_wtime();
    petscSolveCRS_8args(&Arows, &Acols, &Avals, &b, &solver, rtol, maxiter, &pctype, &x, flag, relres, iter, &reshis, times);
    _timestamp = M2C_wtime() - _timestamp;
    printf("Function petscSolveCRS completed in %g seconds.\n", _timestamp);

    /* Deallocate input and marshall out function outputs */
    free_emxArray((emxArray__common*)(&Arows));
    free_emxArray((emxArray__common*)(&Acols));
    free_emxArray((emxArray__common*)(&Avals));
    free_emxArray((emxArray__common*)(&b));
    free_emxArray((emxArray__common*)(&solver));
    /* Nothing to be done for rtol */
    /* Nothing to be done for maxiter */
    free_emxArray((emxArray__common*)(&pctype));
    plhs[0] = move_emxArray_to_mxArray((emxArray__common*)(&x), mxDOUBLE_CLASS);
    mxFree(x.size);
    plhs[1] = move_scalar_to_mxArray(flag, mxINT32_CLASS);
    plhs[2] = move_scalar_to_mxArray(relres, mxDOUBLE_CLASS);
    plhs[3] = move_scalar_to_mxArray(iter, mxINT32_CLASS);
    plhs[4] = move_emxArray_to_mxArray((emxArray__common*)(&reshis), mxDOUBLE_CLASS);
    mxFree(reshis.size);
    _dims[0] = 2;
    plhs[5] = move_array_to_mxArray(times, mxDOUBLE_CLASS, 1, _dims);

}

static void __petscSolveCRS_9args_api(mxArray **plhs, const mxArray ** prhs) {
    emxArray_int32_T     Arows;
    emxArray_int32_T     Acols;
    emxArray_real_T      Avals;
    emxArray_real_T      b;
    emxArray_char_T      solver;
    real64_T             rtol;
    int32_T              maxiter;
    emxArray_char_T      pctype;
    emxArray_char_T      solpack;
    emxArray_real_T      x;
    int32_T             *flag;
    real64_T            *relres;
    int32_T             *iter;
    emxArray_real_T      reshis;
    real64_T            *times;
    double               _timestamp;

    int                  _dims[1];

    /* Marshall in inputs and preallocate outputs */
    if (mxGetNumberOfElements(prhs[0]) && mxGetClassID(prhs[0]) != mxINT32_CLASS)
        mexErrMsgIdAndTxt("petscSolveCRS_9args:WrongInputType",
            "Input argument Arows has incorrect data type; int32 is expected.");
    if (mxGetNumberOfElements(prhs[0]) && mxGetDimensions(prhs[0])[1] != 1) 
        mexErrMsgIdAndTxt("petscSolveCRS_9args:WrongSizeOfInputArg",
            "Dimension 2 of Arows should be equal to 1.");
    alias_mxArray_to_emxArray(prhs[0], (emxArray__common *)(&Arows), "Arows", 1);

    if (mxGetNumberOfElements(prhs[1]) && mxGetClassID(prhs[1]) != mxINT32_CLASS)
        mexErrMsgIdAndTxt("petscSolveCRS_9args:WrongInputType",
            "Input argument Acols has incorrect data type; int32 is expected.");
    if (mxGetNumberOfElements(prhs[1]) && mxGetDimensions(prhs[1])[1] != 1) 
        mexErrMsgIdAndTxt("petscSolveCRS_9args:WrongSizeOfInputArg",
            "Dimension 2 of Acols should be equal to 1.");
    alias_mxArray_to_emxArray(prhs[1], (emxArray__common *)(&Acols), "Acols", 1);

    if (mxGetNumberOfElements(prhs[2]) && mxGetClassID(prhs[2]) != mxDOUBLE_CLASS)
        mexErrMsgIdAndTxt("petscSolveCRS_9args:WrongInputType",
            "Input argument Avals has incorrect data type; double is expected.");
    if (mxGetNumberOfElements(prhs[2]) && mxGetDimensions(prhs[2])[1] != 1) 
        mexErrMsgIdAndTxt("petscSolveCRS_9args:WrongSizeOfInputArg",
            "Dimension 2 of Avals should be equal to 1.");
    alias_mxArray_to_emxArray(prhs[2], (emxArray__common *)(&Avals), "Avals", 1);

    if (mxGetNumberOfElements(prhs[3]) && mxGetClassID(prhs[3]) != mxDOUBLE_CLASS)
        mexErrMsgIdAndTxt("petscSolveCRS_9args:WrongInputType",
            "Input argument b has incorrect data type; double is expected.");
    if (mxGetNumberOfElements(prhs[3]) && mxGetDimensions(prhs[3])[1] != 1) 
        mexErrMsgIdAndTxt("petscSolveCRS_9args:WrongSizeOfInputArg",
            "Dimension 2 of b should be equal to 1.");
    alias_mxArray_to_emxArray(prhs[3], (emxArray__common *)(&b), "b", 1);

    if (mxGetNumberOfElements(prhs[4]) && mxGetClassID(prhs[4]) != mxCHAR_CLASS)
        mexErrMsgIdAndTxt("petscSolveCRS_9args:WrongInputType",
            "Input argument solver has incorrect data type; char is expected.");
    if (mxGetNumberOfElements(prhs[4]) && mxGetDimensions(prhs[4])[0] != 1) 
        mexErrMsgIdAndTxt("petscSolveCRS_9args:WrongSizeOfInputArg",
            "Dimension 1 of solver should be equal to 1.");
    alias_mxArray_to_emxArray(prhs[4], (emxArray__common *)(&solver), "solver", 2);

    if (mxGetNumberOfElements(prhs[5]) && mxGetClassID(prhs[5]) != mxDOUBLE_CLASS)
        mexErrMsgIdAndTxt("petscSolveCRS_9args:WrongInputType",
            "Input argument rtol has incorrect data type; double is expected.");
    if (mxGetNumberOfElements(prhs[5]) != 1)
        mexErrMsgIdAndTxt("petscSolveCRS_9args:WrongSizeOfInputArg",
            "Argument rtol should be a scalar.");
    rtol = *(real64_T*)mxGetData(prhs[5]);

    if (mxGetNumberOfElements(prhs[6]) && mxGetClassID(prhs[6]) != mxINT32_CLASS)
        mexErrMsgIdAndTxt("petscSolveCRS_9args:WrongInputType",
            "Input argument maxiter has incorrect data type; int32 is expected.");
    if (mxGetNumberOfElements(prhs[6]) != 1)
        mexErrMsgIdAndTxt("petscSolveCRS_9args:WrongSizeOfInputArg",
            "Argument maxiter should be a scalar.");
    maxiter = *(int32_T*)mxGetData(prhs[6]);

    if (mxGetNumberOfElements(prhs[7]) && mxGetClassID(prhs[7]) != mxCHAR_CLASS)
        mexErrMsgIdAndTxt("petscSolveCRS_9args:WrongInputType",
            "Input argument pctype has incorrect data type; char is expected.");
    if (mxGetNumberOfElements(prhs[7]) && mxGetDimensions(prhs[7])[0] != 1) 
        mexErrMsgIdAndTxt("petscSolveCRS_9args:WrongSizeOfInputArg",
            "Dimension 1 of pctype should be equal to 1.");
    alias_mxArray_to_emxArray(prhs[7], (emxArray__common *)(&pctype), "pctype", 2);

    if (mxGetNumberOfElements(prhs[8]) && mxGetClassID(prhs[8]) != mxCHAR_CLASS)
        mexErrMsgIdAndTxt("petscSolveCRS_9args:WrongInputType",
            "Input argument solpack has incorrect data type; char is expected.");
    if (mxGetNumberOfElements(prhs[8]) && mxGetDimensions(prhs[8])[0] != 1) 
        mexErrMsgIdAndTxt("petscSolveCRS_9args:WrongSizeOfInputArg",
            "Dimension 1 of solpack should be equal to 1.");
    alias_mxArray_to_emxArray(prhs[8], (emxArray__common *)(&solpack), "solpack", 2);
    init_emxArray((emxArray__common*)(&x), 1);

    flag = (int32_T*)mxMalloc(sizeof(int32_T));

    relres = (real64_T*)mxMalloc(sizeof(real64_T));

    iter = (int32_T*)mxMalloc(sizeof(int32_T));
    init_emxArray((emxArray__common*)(&reshis), 1);

    times = (real64_T*)mxMalloc(sizeof(real64_T) * 2);

    /* Invoke the target function */
    _timestamp = M2C_wtime();
    petscSolveCRS_9args(&Arows, &Acols, &Avals, &b, &solver, rtol, maxiter, &pctype, &solpack, &x, flag, relres, iter, &reshis, times);
    _timestamp = M2C_wtime() - _timestamp;
    printf("Function petscSolveCRS completed in %g seconds.\n", _timestamp);

    /* Deallocate input and marshall out function outputs */
    free_emxArray((emxArray__common*)(&Arows));
    free_emxArray((emxArray__common*)(&Acols));
    free_emxArray((emxArray__common*)(&Avals));
    free_emxArray((emxArray__common*)(&b));
    free_emxArray((emxArray__common*)(&solver));
    /* Nothing to be done for rtol */
    /* Nothing to be done for maxiter */
    free_emxArray((emxArray__common*)(&pctype));
    free_emxArray((emxArray__common*)(&solpack));
    plhs[0] = move_emxArray_to_mxArray((emxArray__common*)(&x), mxDOUBLE_CLASS);
    mxFree(x.size);
    plhs[1] = move_scalar_to_mxArray(flag, mxINT32_CLASS);
    plhs[2] = move_scalar_to_mxArray(relres, mxDOUBLE_CLASS);
    plhs[3] = move_scalar_to_mxArray(iter, mxINT32_CLASS);
    plhs[4] = move_emxArray_to_mxArray((emxArray__common*)(&reshis), mxDOUBLE_CLASS);
    mxFree(reshis.size);
    _dims[0] = 2;
    plhs[5] = move_array_to_mxArray(times, mxDOUBLE_CLASS, 1, _dims);

}

static void __petscSolveCRS_10args_api(mxArray **plhs, const mxArray ** prhs) {
    emxArray_int32_T     Arows;
    emxArray_int32_T     Acols;
    emxArray_real_T      Avals;
    emxArray_real_T      b;
    emxArray_char_T      solver;
    real64_T             rtol;
    int32_T              maxiter;
    emxArray_char_T      pctype;
    emxArray_char_T      solpack;
    emxArray_real_T      x0;
    emxArray_real_T      x;
    int32_T             *flag;
    real64_T            *relres;
    int32_T             *iter;
    emxArray_real_T      reshis;
    real64_T            *times;
    double               _timestamp;

    int                  _dims[1];

    /* Marshall in inputs and preallocate outputs */
    if (mxGetNumberOfElements(prhs[0]) && mxGetClassID(prhs[0]) != mxINT32_CLASS)
        mexErrMsgIdAndTxt("petscSolveCRS_10args:WrongInputType",
            "Input argument Arows has incorrect data type; int32 is expected.");
    if (mxGetNumberOfElements(prhs[0]) && mxGetDimensions(prhs[0])[1] != 1) 
        mexErrMsgIdAndTxt("petscSolveCRS_10args:WrongSizeOfInputArg",
            "Dimension 2 of Arows should be equal to 1.");
    alias_mxArray_to_emxArray(prhs[0], (emxArray__common *)(&Arows), "Arows", 1);

    if (mxGetNumberOfElements(prhs[1]) && mxGetClassID(prhs[1]) != mxINT32_CLASS)
        mexErrMsgIdAndTxt("petscSolveCRS_10args:WrongInputType",
            "Input argument Acols has incorrect data type; int32 is expected.");
    if (mxGetNumberOfElements(prhs[1]) && mxGetDimensions(prhs[1])[1] != 1) 
        mexErrMsgIdAndTxt("petscSolveCRS_10args:WrongSizeOfInputArg",
            "Dimension 2 of Acols should be equal to 1.");
    alias_mxArray_to_emxArray(prhs[1], (emxArray__common *)(&Acols), "Acols", 1);

    if (mxGetNumberOfElements(prhs[2]) && mxGetClassID(prhs[2]) != mxDOUBLE_CLASS)
        mexErrMsgIdAndTxt("petscSolveCRS_10args:WrongInputType",
            "Input argument Avals has incorrect data type; double is expected.");
    if (mxGetNumberOfElements(prhs[2]) && mxGetDimensions(prhs[2])[1] != 1) 
        mexErrMsgIdAndTxt("petscSolveCRS_10args:WrongSizeOfInputArg",
            "Dimension 2 of Avals should be equal to 1.");
    alias_mxArray_to_emxArray(prhs[2], (emxArray__common *)(&Avals), "Avals", 1);

    if (mxGetNumberOfElements(prhs[3]) && mxGetClassID(prhs[3]) != mxDOUBLE_CLASS)
        mexErrMsgIdAndTxt("petscSolveCRS_10args:WrongInputType",
            "Input argument b has incorrect data type; double is expected.");
    if (mxGetNumberOfElements(prhs[3]) && mxGetDimensions(prhs[3])[1] != 1) 
        mexErrMsgIdAndTxt("petscSolveCRS_10args:WrongSizeOfInputArg",
            "Dimension 2 of b should be equal to 1.");
    alias_mxArray_to_emxArray(prhs[3], (emxArray__common *)(&b), "b", 1);

    if (mxGetNumberOfElements(prhs[4]) && mxGetClassID(prhs[4]) != mxCHAR_CLASS)
        mexErrMsgIdAndTxt("petscSolveCRS_10args:WrongInputType",
            "Input argument solver has incorrect data type; char is expected.");
    if (mxGetNumberOfElements(prhs[4]) && mxGetDimensions(prhs[4])[0] != 1) 
        mexErrMsgIdAndTxt("petscSolveCRS_10args:WrongSizeOfInputArg",
            "Dimension 1 of solver should be equal to 1.");
    alias_mxArray_to_emxArray(prhs[4], (emxArray__common *)(&solver), "solver", 2);

    if (mxGetNumberOfElements(prhs[5]) && mxGetClassID(prhs[5]) != mxDOUBLE_CLASS)
        mexErrMsgIdAndTxt("petscSolveCRS_10args:WrongInputType",
            "Input argument rtol has incorrect data type; double is expected.");
    if (mxGetNumberOfElements(prhs[5]) != 1)
        mexErrMsgIdAndTxt("petscSolveCRS_10args:WrongSizeOfInputArg",
            "Argument rtol should be a scalar.");
    rtol = *(real64_T*)mxGetData(prhs[5]);

    if (mxGetNumberOfElements(prhs[6]) && mxGetClassID(prhs[6]) != mxINT32_CLASS)
        mexErrMsgIdAndTxt("petscSolveCRS_10args:WrongInputType",
            "Input argument maxiter has incorrect data type; int32 is expected.");
    if (mxGetNumberOfElements(prhs[6]) != 1)
        mexErrMsgIdAndTxt("petscSolveCRS_10args:WrongSizeOfInputArg",
            "Argument maxiter should be a scalar.");
    maxiter = *(int32_T*)mxGetData(prhs[6]);

    if (mxGetNumberOfElements(prhs[7]) && mxGetClassID(prhs[7]) != mxCHAR_CLASS)
        mexErrMsgIdAndTxt("petscSolveCRS_10args:WrongInputType",
            "Input argument pctype has incorrect data type; char is expected.");
    if (mxGetNumberOfElements(prhs[7]) && mxGetDimensions(prhs[7])[0] != 1) 
        mexErrMsgIdAndTxt("petscSolveCRS_10args:WrongSizeOfInputArg",
            "Dimension 1 of pctype should be equal to 1.");
    alias_mxArray_to_emxArray(prhs[7], (emxArray__common *)(&pctype), "pctype", 2);

    if (mxGetNumberOfElements(prhs[8]) && mxGetClassID(prhs[8]) != mxCHAR_CLASS)
        mexErrMsgIdAndTxt("petscSolveCRS_10args:WrongInputType",
            "Input argument solpack has incorrect data type; char is expected.");
    if (mxGetNumberOfElements(prhs[8]) && mxGetDimensions(prhs[8])[0] != 1) 
        mexErrMsgIdAndTxt("petscSolveCRS_10args:WrongSizeOfInputArg",
            "Dimension 1 of solpack should be equal to 1.");
    alias_mxArray_to_emxArray(prhs[8], (emxArray__common *)(&solpack), "solpack", 2);

    if (mxGetNumberOfElements(prhs[9]) && mxGetClassID(prhs[9]) != mxDOUBLE_CLASS)
        mexErrMsgIdAndTxt("petscSolveCRS_10args:WrongInputType",
            "Input argument x0 has incorrect data type; double is expected.");
    if (mxGetNumberOfElements(prhs[9]) && mxGetDimensions(prhs[9])[1] != 1) 
        mexErrMsgIdAndTxt("petscSolveCRS_10args:WrongSizeOfInputArg",
            "Dimension 2 of x0 should be equal to 1.");
    alias_mxArray_to_emxArray(prhs[9], (emxArray__common *)(&x0), "x0", 1);
    init_emxArray((emxArray__common*)(&x), 1);

    flag = (int32_T*)mxMalloc(sizeof(int32_T));

    relres = (real64_T*)mxMalloc(sizeof(real64_T));

    iter = (int32_T*)mxMalloc(sizeof(int32_T));
    init_emxArray((emxArray__common*)(&reshis), 1);

    times = (real64_T*)mxMalloc(sizeof(real64_T) * 2);

    /* Invoke the target function */
    _timestamp = M2C_wtime();
    petscSolveCRS_10args(&Arows, &Acols, &Avals, &b, &solver, rtol, maxiter, &pctype, &solpack, &x0, &x, flag, relres, iter, &reshis, times);
    _timestamp = M2C_wtime() - _timestamp;
    printf("Function petscSolveCRS completed in %g seconds.\n", _timestamp);

    /* Deallocate input and marshall out function outputs */
    free_emxArray((emxArray__common*)(&Arows));
    free_emxArray((emxArray__common*)(&Acols));
    free_emxArray((emxArray__common*)(&Avals));
    free_emxArray((emxArray__common*)(&b));
    free_emxArray((emxArray__common*)(&solver));
    /* Nothing to be done for rtol */
    /* Nothing to be done for maxiter */
    free_emxArray((emxArray__common*)(&pctype));
    free_emxArray((emxArray__common*)(&solpack));
    free_emxArray((emxArray__common*)(&x0));
    plhs[0] = move_emxArray_to_mxArray((emxArray__common*)(&x), mxDOUBLE_CLASS);
    mxFree(x.size);
    plhs[1] = move_scalar_to_mxArray(flag, mxINT32_CLASS);
    plhs[2] = move_scalar_to_mxArray(relres, mxDOUBLE_CLASS);
    plhs[3] = move_scalar_to_mxArray(iter, mxINT32_CLASS);
    plhs[4] = move_emxArray_to_mxArray((emxArray__common*)(&reshis), mxDOUBLE_CLASS);
    mxFree(reshis.size);
    _dims[0] = 2;
    plhs[5] = move_array_to_mxArray(times, mxDOUBLE_CLASS, 1, _dims);

}

static void __petscSolveCRS_11args_api(mxArray **plhs, const mxArray ** prhs) {
    emxArray_int32_T     Arows;
    emxArray_int32_T     Acols;
    emxArray_real_T      Avals;
    emxArray_real_T      b;
    emxArray_char_T      solver;
    real64_T             rtol;
    int32_T              maxiter;
    emxArray_char_T      pctype;
    emxArray_char_T      solpack;
    emxArray_real_T      x0;
    emxArray_char_T      opts;
    emxArray_real_T      x;
    int32_T             *flag;
    real64_T            *relres;
    int32_T             *iter;
    emxArray_real_T      reshis;
    real64_T            *times;
    double               _timestamp;

    int                  _dims[1];

    /* Marshall in inputs and preallocate outputs */
    if (mxGetNumberOfElements(prhs[0]) && mxGetClassID(prhs[0]) != mxINT32_CLASS)
        mexErrMsgIdAndTxt("petscSolveCRS_11args:WrongInputType",
            "Input argument Arows has incorrect data type; int32 is expected.");
    if (mxGetNumberOfElements(prhs[0]) && mxGetDimensions(prhs[0])[1] != 1) 
        mexErrMsgIdAndTxt("petscSolveCRS_11args:WrongSizeOfInputArg",
            "Dimension 2 of Arows should be equal to 1.");
    alias_mxArray_to_emxArray(prhs[0], (emxArray__common *)(&Arows), "Arows", 1);

    if (mxGetNumberOfElements(prhs[1]) && mxGetClassID(prhs[1]) != mxINT32_CLASS)
        mexErrMsgIdAndTxt("petscSolveCRS_11args:WrongInputType",
            "Input argument Acols has incorrect data type; int32 is expected.");
    if (mxGetNumberOfElements(prhs[1]) && mxGetDimensions(prhs[1])[1] != 1) 
        mexErrMsgIdAndTxt("petscSolveCRS_11args:WrongSizeOfInputArg",
            "Dimension 2 of Acols should be equal to 1.");
    alias_mxArray_to_emxArray(prhs[1], (emxArray__common *)(&Acols), "Acols", 1);

    if (mxGetNumberOfElements(prhs[2]) && mxGetClassID(prhs[2]) != mxDOUBLE_CLASS)
        mexErrMsgIdAndTxt("petscSolveCRS_11args:WrongInputType",
            "Input argument Avals has incorrect data type; double is expected.");
    if (mxGetNumberOfElements(prhs[2]) && mxGetDimensions(prhs[2])[1] != 1) 
        mexErrMsgIdAndTxt("petscSolveCRS_11args:WrongSizeOfInputArg",
            "Dimension 2 of Avals should be equal to 1.");
    alias_mxArray_to_emxArray(prhs[2], (emxArray__common *)(&Avals), "Avals", 1);

    if (mxGetNumberOfElements(prhs[3]) && mxGetClassID(prhs[3]) != mxDOUBLE_CLASS)
        mexErrMsgIdAndTxt("petscSolveCRS_11args:WrongInputType",
            "Input argument b has incorrect data type; double is expected.");
    if (mxGetNumberOfElements(prhs[3]) && mxGetDimensions(prhs[3])[1] != 1) 
        mexErrMsgIdAndTxt("petscSolveCRS_11args:WrongSizeOfInputArg",
            "Dimension 2 of b should be equal to 1.");
    alias_mxArray_to_emxArray(prhs[3], (emxArray__common *)(&b), "b", 1);

    if (mxGetNumberOfElements(prhs[4]) && mxGetClassID(prhs[4]) != mxCHAR_CLASS)
        mexErrMsgIdAndTxt("petscSolveCRS_11args:WrongInputType",
            "Input argument solver has incorrect data type; char is expected.");
    if (mxGetNumberOfElements(prhs[4]) && mxGetDimensions(prhs[4])[0] != 1) 
        mexErrMsgIdAndTxt("petscSolveCRS_11args:WrongSizeOfInputArg",
            "Dimension 1 of solver should be equal to 1.");
    alias_mxArray_to_emxArray(prhs[4], (emxArray__common *)(&solver), "solver", 2);

    if (mxGetNumberOfElements(prhs[5]) && mxGetClassID(prhs[5]) != mxDOUBLE_CLASS)
        mexErrMsgIdAndTxt("petscSolveCRS_11args:WrongInputType",
            "Input argument rtol has incorrect data type; double is expected.");
    if (mxGetNumberOfElements(prhs[5]) != 1)
        mexErrMsgIdAndTxt("petscSolveCRS_11args:WrongSizeOfInputArg",
            "Argument rtol should be a scalar.");
    rtol = *(real64_T*)mxGetData(prhs[5]);

    if (mxGetNumberOfElements(prhs[6]) && mxGetClassID(prhs[6]) != mxINT32_CLASS)
        mexErrMsgIdAndTxt("petscSolveCRS_11args:WrongInputType",
            "Input argument maxiter has incorrect data type; int32 is expected.");
    if (mxGetNumberOfElements(prhs[6]) != 1)
        mexErrMsgIdAndTxt("petscSolveCRS_11args:WrongSizeOfInputArg",
            "Argument maxiter should be a scalar.");
    maxiter = *(int32_T*)mxGetData(prhs[6]);

    if (mxGetNumberOfElements(prhs[7]) && mxGetClassID(prhs[7]) != mxCHAR_CLASS)
        mexErrMsgIdAndTxt("petscSolveCRS_11args:WrongInputType",
            "Input argument pctype has incorrect data type; char is expected.");
    if (mxGetNumberOfElements(prhs[7]) && mxGetDimensions(prhs[7])[0] != 1) 
        mexErrMsgIdAndTxt("petscSolveCRS_11args:WrongSizeOfInputArg",
            "Dimension 1 of pctype should be equal to 1.");
    alias_mxArray_to_emxArray(prhs[7], (emxArray__common *)(&pctype), "pctype", 2);

    if (mxGetNumberOfElements(prhs[8]) && mxGetClassID(prhs[8]) != mxCHAR_CLASS)
        mexErrMsgIdAndTxt("petscSolveCRS_11args:WrongInputType",
            "Input argument solpack has incorrect data type; char is expected.");
    if (mxGetNumberOfElements(prhs[8]) && mxGetDimensions(prhs[8])[0] != 1) 
        mexErrMsgIdAndTxt("petscSolveCRS_11args:WrongSizeOfInputArg",
            "Dimension 1 of solpack should be equal to 1.");
    alias_mxArray_to_emxArray(prhs[8], (emxArray__common *)(&solpack), "solpack", 2);

    if (mxGetNumberOfElements(prhs[9]) && mxGetClassID(prhs[9]) != mxDOUBLE_CLASS)
        mexErrMsgIdAndTxt("petscSolveCRS_11args:WrongInputType",
            "Input argument x0 has incorrect data type; double is expected.");
    if (mxGetNumberOfElements(prhs[9]) && mxGetDimensions(prhs[9])[1] != 1) 
        mexErrMsgIdAndTxt("petscSolveCRS_11args:WrongSizeOfInputArg",
            "Dimension 2 of x0 should be equal to 1.");
    alias_mxArray_to_emxArray(prhs[9], (emxArray__common *)(&x0), "x0", 1);

    if (mxGetNumberOfElements(prhs[10]) && mxGetClassID(prhs[10]) != mxCHAR_CLASS)
        mexErrMsgIdAndTxt("petscSolveCRS_11args:WrongInputType",
            "Input argument opts has incorrect data type; char is expected.");
    if (mxGetNumberOfElements(prhs[10]) && mxGetDimensions(prhs[10])[0] != 1) 
        mexErrMsgIdAndTxt("petscSolveCRS_11args:WrongSizeOfInputArg",
            "Dimension 1 of opts should be equal to 1.");
    alias_mxArray_to_emxArray(prhs[10], (emxArray__common *)(&opts), "opts", 2);
    init_emxArray((emxArray__common*)(&x), 1);

    flag = (int32_T*)mxMalloc(sizeof(int32_T));

    relres = (real64_T*)mxMalloc(sizeof(real64_T));

    iter = (int32_T*)mxMalloc(sizeof(int32_T));
    init_emxArray((emxArray__common*)(&reshis), 1);

    times = (real64_T*)mxMalloc(sizeof(real64_T) * 2);

    /* Invoke the target function */
    _timestamp = M2C_wtime();
    petscSolveCRS_11args(&Arows, &Acols, &Avals, &b, &solver, rtol, maxiter, &pctype, &solpack, &x0, &opts, &x, flag, relres, iter, &reshis, times);
    _timestamp = M2C_wtime() - _timestamp;
    printf("Function petscSolveCRS completed in %g seconds.\n", _timestamp);

    /* Deallocate input and marshall out function outputs */
    free_emxArray((emxArray__common*)(&Arows));
    free_emxArray((emxArray__common*)(&Acols));
    free_emxArray((emxArray__common*)(&Avals));
    free_emxArray((emxArray__common*)(&b));
    free_emxArray((emxArray__common*)(&solver));
    /* Nothing to be done for rtol */
    /* Nothing to be done for maxiter */
    free_emxArray((emxArray__common*)(&pctype));
    free_emxArray((emxArray__common*)(&solpack));
    free_emxArray((emxArray__common*)(&x0));
    free_emxArray((emxArray__common*)(&opts));
    plhs[0] = move_emxArray_to_mxArray((emxArray__common*)(&x), mxDOUBLE_CLASS);
    mxFree(x.size);
    plhs[1] = move_scalar_to_mxArray(flag, mxINT32_CLASS);
    plhs[2] = move_scalar_to_mxArray(relres, mxDOUBLE_CLASS);
    plhs[3] = move_scalar_to_mxArray(iter, mxINT32_CLASS);
    plhs[4] = move_emxArray_to_mxArray((emxArray__common*)(&reshis), mxDOUBLE_CLASS);
    mxFree(reshis.size);
    _dims[0] = 2;
    plhs[5] = move_array_to_mxArray(times, mxDOUBLE_CLASS, 1, _dims);

}


void mexFunction(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[]) {
    /* Temporary copy for mex outputs. */
    mxArray *outputs[6] = {NULL, NULL, NULL, NULL, NULL, NULL};
    int i;
    int nOutputs = (nlhs < 1 ? 1 : nlhs);

    if (nrhs == 0) {
        if (nlhs > 6)
            mexErrMsgIdAndTxt("petscSolveCRS:TooManyOutputArguments",
                "Too many output arguments for entry-point petscSolveCRS.\n");
        /* Call the API function. */
        __petscSolveCRS_api(outputs, prhs);
    }
    else if (nrhs == 4) {
        if (nlhs > 6)
            mexErrMsgIdAndTxt("petscSolveCRS_4args:TooManyOutputArguments",
                "Too many output arguments for entry-point petscSolveCRS_4args.\n");
        /* Call the API function. */
        __petscSolveCRS_4args_api(outputs, prhs);
    }
    else if (nrhs == 5) {
        if (nlhs > 6)
            mexErrMsgIdAndTxt("petscSolveCRS_5args:TooManyOutputArguments",
                "Too many output arguments for entry-point petscSolveCRS_5args.\n");
        /* Call the API function. */
        __petscSolveCRS_5args_api(outputs, prhs);
    }
    else if (nrhs == 6) {
        if (nlhs > 6)
            mexErrMsgIdAndTxt("petscSolveCRS_6args:TooManyOutputArguments",
                "Too many output arguments for entry-point petscSolveCRS_6args.\n");
        /* Call the API function. */
        __petscSolveCRS_6args_api(outputs, prhs);
    }
    else if (nrhs == 7) {
        if (nlhs > 6)
            mexErrMsgIdAndTxt("petscSolveCRS_7args:TooManyOutputArguments",
                "Too many output arguments for entry-point petscSolveCRS_7args.\n");
        /* Call the API function. */
        __petscSolveCRS_7args_api(outputs, prhs);
    }
    else if (nrhs == 8) {
        if (nlhs > 6)
            mexErrMsgIdAndTxt("petscSolveCRS_8args:TooManyOutputArguments",
                "Too many output arguments for entry-point petscSolveCRS_8args.\n");
        /* Call the API function. */
        __petscSolveCRS_8args_api(outputs, prhs);
    }
    else if (nrhs == 9) {
        if (nlhs > 6)
            mexErrMsgIdAndTxt("petscSolveCRS_9args:TooManyOutputArguments",
                "Too many output arguments for entry-point petscSolveCRS_9args.\n");
        /* Call the API function. */
        __petscSolveCRS_9args_api(outputs, prhs);
    }
    else if (nrhs == 10) {
        if (nlhs > 6)
            mexErrMsgIdAndTxt("petscSolveCRS_10args:TooManyOutputArguments",
                "Too many output arguments for entry-point petscSolveCRS_10args.\n");
        /* Call the API function. */
        __petscSolveCRS_10args_api(outputs, prhs);
    }
    else if (nrhs == 11) {
        if (nlhs > 6)
            mexErrMsgIdAndTxt("petscSolveCRS_11args:TooManyOutputArguments",
                "Too many output arguments for entry-point petscSolveCRS_11args.\n");
        /* Call the API function. */
        __petscSolveCRS_11args_api(outputs, prhs);
    }
    else
        mexErrMsgIdAndTxt("petscSolveCRS:WrongNumberOfInputs",
            "Incorrect number of input variables for entry-point petscSolveCRS.");

    /* Copy over outputs to the caller. */
    for (i = 0; i < nOutputs; ++i) {
        plhs[i] = outputs[i];
    }
}
